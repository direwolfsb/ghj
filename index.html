<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title> AI project</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b1020; overflow: hidden; }
    canvas { display:block; width:100vw; height:100vh; }
    .hint{
      position:fixed; left:50%; transform:translateX(-50%);
      bottom:14px; font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(255,255,255,.85); user-select:none;
      background: rgba(0,0,0,.35); padding:8px 12px; border-radius:999px;
      backdrop-filter: blur(6px);
      max-width: 92vw;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align:center;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint">Move: WASD/Arrows â€¢ Mobile: drag flower â€¢ Deliver to envelope ðŸ’Œ â€¢ Tap empty space to replay</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // ==== CUSTOMIZE THIS ====
  const TO_NAME = "Subs";
  const MESSAGE =
    "Iâ€™d give you a real rose, but this one is digital because Iâ€™m eco-friendly, broke, and my credit card is maxed out ðŸŒ¹\n\nAlso, thanks for sticking with me fr.";
  // ========================

  // === MAIN BACKGROUND ===
  // keep your outside background SAME as before (night gradient + stars)
  // (so we do NOT use your image as the whole scene)

  // === NOTE BOX BACKGROUND IMAGE (INSIDE MESSAGE BOX ONLY) ===
  // Put your image in the same folder as this HTML and name it: note_bg.png
  const noteBg = new Image();
  noteBg.src = "note_bg.png";
  let noteBgReady = false;
  noteBg.onload = () => (noteBgReady = true);

  // Game settings
  const SPARKLE_TARGET = 10;
  const DELIVERY_RADIUS = 80;

  let DPR;
  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(innerWidth  * DPR);
    canvas.height = Math.floor(innerHeight * DPR);
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener("resize", resize, {passive:true});
  resize();

  // Helpers
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp  = (a,b,t)=>a+(b-a)*t;
  const dist2 = (ax,ay,bx,by)=>((ax-bx)**2+(ay-by)**2);
  const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
  const easeInOutSine = t => -(Math.cos(Math.PI * t) - 1) / 2;

  function px(){ return { w: innerWidth, h: innerHeight }; }

  // Background stars
  const stars = Array.from({length: 140}, () => ({
    x: Math.random(), y: Math.random(), r: Math.random()*1.6+0.3, tw: Math.random()*2*Math.PI
  }));

  function drawBackground(time){
    const {w,h} = px();

    // gradient sky (outside background stays same)
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, "#0b1020");
    g.addColorStop(1, "#1a0f2b");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // soft glow
    ctx.globalAlpha = 0.20;
    const glow = ctx.createRadialGradient(w*0.25,h*0.2, 10, w*0.25,h*0.2, h*0.9);
    glow.addColorStop(0, "#7b5cff");
    glow.addColorStop(1, "transparent");
    ctx.fillStyle = glow;
    ctx.fillRect(0,0,w,h);
    ctx.globalAlpha = 1;

    // stars
    for(const s of stars){
      const tw = 0.4 + 0.6*Math.sin(time*0.001 + s.tw);
      ctx.globalAlpha = 0.35 + 0.35*tw;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(s.x*w, s.y*h, s.r*(0.8+0.5*tw), 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function drawGround(){
    const {w,h} = px();
    const g = ctx.createLinearGradient(0,h*0.72,0,h);
    g.addColorStop(0, "#102018");
    g.addColorStop(1, "#06130f");
    ctx.fillStyle = g;
    ctx.fillRect(0,h*0.72,w,h*0.28);

    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "#163022";
    ctx.beginPath();
    ctx.moveTo(0,h*0.78);
    ctx.quadraticCurveTo(w*0.25,h*0.70, w*0.55,h*0.80);
    ctx.quadraticCurveTo(w*0.80,h*0.90, w,h*0.78);
    ctx.lineTo(w,h);
    ctx.lineTo(0,h);
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Sparkle particles (visual)
  const sparkles = [];
  function spawnSparkle(x,y, n=8){
    for(let i=0;i<n;i++){
      sparkles.push({
        x,y,
        vx:(Math.random()*2-1)*0.9,
        vy:(Math.random()*2-1)*0.9,
        life: 1,
        s: Math.random()*2+1,
        hue: 45 + Math.random()*25
      });
    }
  }
  function updateSparkles(dt){
    for(let i=sparkles.length-1;i>=0;i--){
      const p = sparkles[i];
      p.life -= dt*1.2;
      p.x += p.vx*60*dt;
      p.y += p.vy*60*dt;
      p.vx *= 0.98; p.vy *= 0.98;
      if(p.life <= 0) sparkles.splice(i,1);
    }
  }
  function drawSparkles(){
    for(const p of sparkles){
      ctx.save();
      ctx.globalAlpha = clamp(p.life,0,1);
      ctx.fillStyle = `hsl(${p.hue} 95% 65%)`;
      ctx.translate(p.x,p.y);
      ctx.rotate((1-p.life)*5);
      ctx.beginPath();
      ctx.moveTo(0,-p.s*2);
      ctx.lineTo(p.s*0.7, -p.s*0.5);
      ctx.lineTo(p.s*2, 0);
      ctx.lineTo(p.s*0.7, p.s*0.5);
      ctx.lineTo(0, p.s*2);
      ctx.lineTo(-p.s*0.7, p.s*0.5);
      ctx.lineTo(-p.s*2, 0);
      ctx.lineTo(-p.s*0.7, -p.s*0.5);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
    ctx.globalAlpha = 1;
  }

  // Collectibles (game)
  const collectibles = [];
  function resetCollectibles(){
    collectibles.length = 0;
    const {w,h} = px();
    for(let i=0;i<SPARKLE_TARGET;i++){
      collectibles.push({
        x: w*(0.12 + Math.random()*0.55),
        y: h*(0.12 + Math.random()*0.55),
        r: 12 + Math.random()*6,
        taken: false,
        tw: Math.random()*Math.PI*2
      });
    }
  }
  resetCollectibles();

  function drawCollectibles(time){
    for(const c of collectibles){
      if(c.taken) continue;
      const tw = 0.6 + 0.4*Math.sin(time*0.004 + c.tw);
      ctx.save();
      ctx.globalAlpha = 0.75 + 0.25*tw;
      ctx.translate(c.x, c.y);
      ctx.rotate((1-tw)*0.8);
      ctx.fillStyle = "#ffcc55";
      ctx.beginPath();
      const r1 = c.r, r2 = c.r*0.45;
      for(let i=0;i<10;i++){
        const a = (Math.PI*2*i)/10 - Math.PI/2;
        const rr = i%2===0 ? r1 : r2;
        ctx.lineTo(Math.cos(a)*rr, Math.sin(a)*rr);
      }
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
  }

  // Input
  const keys = new Set();
  addEventListener("keydown", (e)=> keys.add(e.key.toLowerCase()));
  addEventListener("keyup",   (e)=> keys.delete(e.key.toLowerCase()));

  const state = {
    t: 0,
    phase: 0, // 0 grow, 1 bloom, 2 play, 3 deliver/open, 4 note
    score: 0,
    flower: { x: 0, y: 0, vx: 0, vy: 0 },
    dragging: false,
    dragOffsetX: 0,
    dragOffsetY: 0,
    _deliverStart: 0,
    replay(){
      this.t=0; this.phase=0; sparkles.length=0;
      this.score=0;
      resetCollectibles();
    }
  };

  canvas.addEventListener("pointerdown", (e)=>{
    const mx = e.clientX, my = e.clientY;
    if(dist2(mx,my, state.flower.x, state.flower.y) < 70*70){
      state.dragging = true;
      state.dragOffsetX = state.flower.x - mx;
      state.dragOffsetY = state.flower.y - my;
      canvas.setPointerCapture(e.pointerId);
    } else {
      state.replay();
    }
  }, {passive:false});

  canvas.addEventListener("pointermove", (e)=>{
    if(!state.dragging) return;
    state.flower.x = e.clientX + state.dragOffsetX;
    state.flower.y = e.clientY + state.dragOffsetY;
  }, {passive:true});

  canvas.addEventListener("pointerup", ()=>{ state.dragging = false; }, {passive:true});

  function drawEnvelope(x,y, openAmount){
    ctx.save();
    ctx.translate(x,y);

    const w = 220, h = 140;

    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(0, h*0.62, w*0.52, h*0.14, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.fillStyle = "#f7f1e5";
    ctx.strokeStyle = "rgba(0,0,0,.12)";
    ctx.lineWidth = 2;
    roundRect(-w/2, -h/2, w, h, 14);
    ctx.fill(); ctx.stroke();

    ctx.globalAlpha = 0.6;
    ctx.fillStyle = "#f1e7d6";
    roundRect(-w/2+10, -h/2+10, w-20, h-20, 12);
    ctx.fill();
    ctx.globalAlpha = 1;

    const flapAngle = lerp(0, -Math.PI*0.92, easeOutCubic(openAmount));
    ctx.save();
    ctx.translate(0, -h/2);
    ctx.rotate(flapAngle);
    ctx.fillStyle = "#fbf6ee";
    ctx.strokeStyle = "rgba(0,0,0,.10)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-w/2, 0);
    ctx.lineTo(0, h*0.62);
    ctx.lineTo(w/2, 0);
    ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.restore();

    ctx.fillStyle = "#efe4d2";
    ctx.beginPath();
    ctx.moveTo(-w/2, h/2);
    ctx.lineTo(0, 0);
    ctx.lineTo(w/2, h/2);
    ctx.closePath();
    ctx.fill();

    ctx.save();
    ctx.translate(0, h*0.18);
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "#ff5a8a";
    heart(0,0, 14);
    ctx.fill();
    ctx.restore();

    ctx.restore();

    function roundRect(x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }
    function heart(cx,cy,s){
      ctx.beginPath();
      ctx.moveTo(cx, cy + s*0.30);
      ctx.bezierCurveTo(cx - s, cy - s*0.35, cx - s*0.20, cy - s*1.05, cx, cy - s*0.40);
      ctx.bezierCurveTo(cx + s*0.20, cy - s*1.05, cx + s, cy - s*0.35, cx, cy + s*0.30);
      ctx.closePath();
    }
  }

  // Wrap text so message stays inside note
  function wrapTextToLines(text, maxWidth){
    const rawLines = text.split("\n");
    const lines = [];
    for(const raw of rawLines){
      const words = raw.split(/\s+/).filter(Boolean);
      if(words.length === 0){ lines.push(""); continue; }
      let line = words[0];
      for(let i=1;i<words.length;i++){
        const test = line + " " + words[i];
        if(ctx.measureText(test).width <= maxWidth) line = test;
        else { lines.push(line); line = words[i]; }
      }
      lines.push(line);
    }
    return lines;
  }

  // âœ… NOTE with your image as background INSIDE the box only
  function drawNote(x,y, alpha){
    const w=390, h=260;

    // 1) Draw clipped image background inside rounded note
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(x,y);
    ctx.rotate(-0.03);

    ctx.beginPath();
    ctx.roundRect(-w/2, -h/2, w, h, 16);
    ctx.clip();

    if(noteBgReady){
      const iw = noteBg.naturalWidth, ih = noteBg.naturalHeight;
      const scale = Math.max(w/iw, h/ih);
      const dw = iw * scale;
      const dh = ih * scale;
      const dx = -dw/2;
      const dy = -dh/2;
      ctx.drawImage(noteBg, dx, dy, dw, dh);
    } else {
      ctx.fillStyle = "#fffaf2";
      ctx.fillRect(-w/2, -h/2, w, h);
    }

    // 2) Overlay for readability
    ctx.fillStyle = "rgba(255,255,255,0.78)";
    ctx.fillRect(-w/2, -h/2, w, h);

    ctx.restore();

    // 3) Border + Text
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(x,y);
    ctx.rotate(-0.03);

    ctx.strokeStyle = "rgba(0,0,0,0.12)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(-w/2, -h/2, w, h, 16);
    ctx.stroke();

    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.font = "700 18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(`To: ${TO_NAME}`, -w/2 + 22, -h/2 + 44);

    ctx.font = "18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const maxTextWidth = w - 44;
    const wrapped = wrapTextToLines(MESSAGE, maxTextWidth);

    let yy = -h/2 + 80;
    const lineH = 26;
    const maxLines = Math.floor((h - 105) / lineH);

    for(const line of wrapped.slice(0, maxLines)){
      ctx.fillText(line, -w/2 + 22, yy);
      yy += lineH;
    }

    ctx.restore();
  }

  function drawFlower(x,y, scale, bob, petalOpen){
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    ctx.rotate(bob);

    ctx.lineCap="round";
    ctx.strokeStyle = "#39c172";
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.moveTo(0, 160);
    ctx.quadraticCurveTo(-18, 70, 0, 0);
    ctx.stroke();

    ctx.fillStyle = "#2bbf6a";
    leaf(-18, 90, -0.7);
    leaf(18, 110, 0.8);

    ctx.fillStyle = "#ffcc3d";
    ctx.beginPath();
    ctx.arc(0, 0, 22, 0, Math.PI*2);
    ctx.fill();

    const petals = 8;
    for(let i=0;i<petals;i++){
      const a = (Math.PI*2*i)/petals;
      const open = lerp(0.35, 1.0, petalOpen);
      ctx.save();
      ctx.rotate(a);
      ctx.translate(0, -42*open);
      const grad = ctx.createRadialGradient(0,-10,6, 0,-10, 44);
      grad.addColorStop(0, "#ffd4e2");
      grad.addColorStop(1, "#ff6aa2");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(0, 0, 18, 42, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "rgba(255,255,255,.9)";
    ctx.beginPath(); ctx.arc(-8,-6,4,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(10,-3,3,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;

    ctx.restore();

    function leaf(x,y, rot){
      ctx.save();
      ctx.translate(x,y);
      ctx.rotate(rot);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.quadraticCurveTo(50,-10, 60,20);
      ctx.quadraticCurveTo(30,45, 0,0);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
  }

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    const {w,h} = px();

    drawBackground(now);
    drawGround();

    const envX = w*0.74;
    const envY = h*0.62;
    const baseX = w*0.28;
    const baseY = h*0.72;

    if(state.t < 0.05){
      state.flower.x = baseX;
      state.flower.y = baseY - 190;
    }

    state.t += dt;

    const growT = 1.6, bloomT = 0.9;
    const deliverT = 1.5, noteT = 1.6;

    if(state.phase === 0 && state.t > growT) state.phase = 1;
    if(state.phase === 1 && state.t > growT + bloomT) state.phase = 2;

    let flowerX = state.flower.x;
    let flowerY = state.flower.y;
    let stemScale = 1, petalOpen = 1;
    let bob = Math.sin(now*0.008)*0.03;

    // grow
    if(state.phase === 0){
      const p = easeOutCubic(clamp(state.t/growT,0,1));
      stemScale = lerp(0.25, 1.0, p);
      petalOpen = 0.15 * p;
      flowerX = baseX;
      flowerY = baseY - lerp(30, 190, p);
      state.flower.x = flowerX; state.flower.y = flowerY;
      if(Math.random() < dt*6) spawnSparkle(baseX, baseY - 120, 1);
    }

    // bloom
    if(state.phase === 1){
      const p = easeInOutSine(clamp((state.t - growT)/bloomT,0,1));
      stemScale = 1.0;
      petalOpen = lerp(0.15, 1.0, p);
      flowerX = baseX;
      flowerY = baseY - 190;
      state.flower.x = flowerX; state.flower.y = flowerY;
      if(Math.random() < dt*14) spawnSparkle(flowerX + (Math.random()*60-30), flowerY + (Math.random()*60-30), 1);
    }

    let openAmount = 0, noteAlpha = 0;

    // play
    if(state.phase === 2){
      drawCollectibles(now);

      if(!state.dragging){
        const accel = 1200;
        let ax = 0, ay = 0;
        const k = (s)=>keys.has(s);

        if(k("arrowleft")||k("a")) ax -= 1;
        if(k("arrowright")||k("d")) ax += 1;
        if(k("arrowup")||k("w")) ay -= 1;
        if(k("arrowdown")||k("s")) ay += 1;

        state.flower.vx += ax * accel * dt;
        state.flower.vy += ay * accel * dt;

        state.flower.vx *= 0.88;
        state.flower.vy *= 0.88;

        const maxV = 520;
        state.flower.vx = clamp(state.flower.vx, -maxV, maxV);
        state.flower.vy = clamp(state.flower.vy, -maxV, maxV);

        state.flower.x += state.flower.vx * dt;
        state.flower.y += state.flower.vy * dt;
      }

      state.flower.x = clamp(state.flower.x, 40, w - 40);
      state.flower.y = clamp(state.flower.y, 60, h*0.72 - 20);

      flowerX = state.flower.x;
      flowerY = state.flower.y + Math.sin(now*0.006)*4;

      for(const c of collectibles){
        if(c.taken) continue;
        if(dist2(flowerX, flowerY, c.x, c.y) < (c.r+30)*(c.r+30)){
          c.taken = true;
          state.score++;
          spawnSparkle(c.x, c.y, 10);
        }
      }

      if(dist2(flowerX, flowerY, envX, envY) < DELIVERY_RADIUS*DELIVERY_RADIUS){
        state.phase = 3;
        state._deliverStart = now;
        spawnSparkle(envX, envY, 18);
      }

      if(Math.random() < dt*6) spawnSparkle(flowerX, flowerY, 1);
    }

    // deliver + note
    if(state.phase === 3 || state.phase === 4){
      const deliverElapsed = (now - (state._deliverStart || now)) / 1000;

      if(deliverElapsed < deliverT){
        const p = easeOutCubic(clamp(deliverElapsed/deliverT,0,1));
        flowerX = lerp(state.flower.x, envX, p);
        flowerY = lerp(state.flower.y, envY - 10, p);
        openAmount = easeOutCubic(clamp((deliverElapsed/deliverT - 0.30)/0.70, 0, 1));
        if(Math.random() < dt*18) spawnSparkle(flowerX, flowerY, 2);
      } else {
        state.phase = 4;
        openAmount = 1;
        const noteElapsed = deliverElapsed - deliverT;
        noteAlpha = easeOutCubic(clamp(noteElapsed/noteT,0,1));
        flowerX = envX;
        flowerY = envY - 10;
      }
    }

    drawEnvelope(envX, envY, openAmount);
    drawFlower(flowerX, flowerY, stemScale, bob, petalOpen);

    if(noteAlpha > 0){
      drawNote(envX - 140, envY - 250, noteAlpha);
    }

    updateSparkles(dt);
    drawSparkles();

    // HUD
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(255,255,255,.88)";
    ctx.font = "800 22px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Rose Day Delivery ðŸŒ¹", 24, 42);

    ctx.globalAlpha = 0.80;
    ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    if(state.phase === 2){
      ctx.fillText(`Sparkles: ${state.score}/${SPARKLE_TARGET} â€¢ Deliver to envelope ðŸ’Œ`, 24, 70);
    } else if(state.phase >= 3){
      ctx.fillText(`Delivered âœ…  Sparkles: ${state.score}/${SPARKLE_TARGET}`, 24, 70);
    } else {
      ctx.fillText("Magic growingâ€¦", 24, 70);
    }
    ctx.restore();

    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
