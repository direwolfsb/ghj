<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />

  <!-- Mobile-friendly viewport -->
  <meta name="viewport"
        content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />

  <title>AI project</title>

  <style>
    :root { --vh: 1vh; }

    html, body {
      height: 100%;
      margin: 0;
      background: #0b1020;
      overflow: hidden;
      overscroll-behavior: none;
      touch-action: none;
    }

    canvas {
      display: block;
      width: 100vw;
      height: calc(var(--vh) * 100);
      touch-action: none;
    }

    .hint{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: max(14px, env(safe-area-inset-bottom));
      font: 14px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(255,255,255,.88);
      user-select: none;
      background: rgba(0,0,0,.35);
      padding: 8px 12px;
      border-radius: 999px;
      backdrop-filter: blur(6px);
      max-width: 92vw;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: center;
      pointer-events: none;
    }

    /* Optional joystick (mobile only) */
    .joy {
      position: fixed;
      left: max(16px, env(safe-area-inset-left));
      bottom: calc(max(16px, env(safe-area-inset-bottom)) + 52px);
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: rgba(255,255,255,.07);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(8px);
      display: none; /* shown via JS on touch devices */
      touch-action: none;
      user-select: none;
    }
    .joy .knob{
      position: absolute;
      left: 50%;
      top: 50%;
      width: 52px;
      height: 52px;
      border-radius: 50%;
      transform: translate(-50%,-50%);
      background: rgba(255,255,255,.18);
      border: 1px solid rgba(255,255,255,.18);
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="joy" id="joy"><div class="knob" id="knob"></div></div>
  <div class="hint">Move: WASD/Arrows â€¢ Mobile: drag flower or joystick â€¢ Deliver to envelope ðŸ’Œ â€¢ Tap empty space to replay</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  // ==== CUSTOMIZE THIS ====
  const TO_NAME = "Subs";
  const MESSAGE =
    "Iâ€™d give you a real rose, but this one is digital because Iâ€™m eco-friendly, broke, and my credit card is maxed out ðŸŒ¹\n\nAlso, thanks for sticking with me fr.";
  // ========================

  // === NOTE BOX BACKGROUND IMAGE (INSIDE MESSAGE BOX ONLY) ===
  // Put your image in the same folder as this HTML and name it: note_bg.png
  const noteBg = new Image();
  noteBg.src = "note_bg.png";
  let noteBgReady = false;
  noteBg.onload = () => (noteBgReady = true);

  // Game settings
  const SPARKLE_TARGET = 10;
  const DELIVERY_RADIUS = 80;

  // ---------- Mobile viewport height fix (iOS) ----------
  function setVh(){
    const vh = (window.visualViewport ? window.visualViewport.height : window.innerHeight) * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  }
  setVh();
  window.addEventListener('resize', setVh, {passive:true});
  window.visualViewport && window.visualViewport.addEventListener('resize', setVh, {passive:true});

  let DPR;
  function resize(){
    const w = window.innerWidth;
    const h = window.visualViewport ? window.visualViewport.height : window.innerHeight;
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener("resize", resize, {passive:true});
  resize();

  // Prevent iOS scrolling/pull-to-refresh on canvas
  canvas.addEventListener('touchstart', (e)=>e.preventDefault(), {passive:false});
  canvas.addEventListener('touchmove',  (e)=>e.preventDefault(), {passive:false});
  canvas.addEventListener('touchend',   (e)=>e.preventDefault(), {passive:false});

  // Helpers
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp  = (a,b,t)=>a+(b-a)*t;
  const dist2 = (ax,ay,bx,by)=>((ax-bx)**2+(ay-by)**2);
  const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
  const easeInOutSine = t => -(Math.cos(Math.PI * t) - 1) / 2;

  function px(){
    const w = window.innerWidth;
    const h = window.visualViewport ? window.visualViewport.height : window.innerHeight;
    return { w, h };
  }

  // Background stars
  const stars = Array.from({length: 140}, () => ({
    x: Math.random(), y: Math.random(), r: Math.random()*1.6+0.3, tw: Math.random()*2*Math.PI
  }));

  function drawBackground(time){
    const {w,h} = px();

    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, "#0b1020");
    g.addColorStop(1, "#1a0f2b");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    ctx.globalAlpha = 0.20;
    const glow = ctx.createRadialGradient(w*0.25,h*0.2, 10, w*0.25,h*0.2, h*0.9);
    glow.addColorStop(0, "#7b5cff");
    glow.addColorStop(1, "transparent");
    ctx.fillStyle = glow;
    ctx.fillRect(0,0,w,h);
    ctx.globalAlpha = 1;

    for(const s of stars){
      const tw = 0.4 + 0.6*Math.sin(time*0.001 + s.tw);
      ctx.globalAlpha = 0.35 + 0.35*tw;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(s.x*w, s.y*h, s.r*(0.8+0.5*tw), 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function drawGround(){
    const {w,h} = px();
    const g = ctx.createLinearGradient(0,h*0.72,0,h);
    g.addColorStop(0, "#102018");
    g.addColorStop(1, "#06130f");
    ctx.fillStyle = g;
    ctx.fillRect(0,h*0.72,w,h*0.28);

    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "#163022";
    ctx.beginPath();
    ctx.moveTo(0,h*0.78);
    ctx.quadraticCurveTo(w*0.25,h*0.70, w*0.55,h*0.80);
    ctx.quadraticCurveTo(w*0.80,h*0.90, w,h*0.78);
    ctx.lineTo(w,h);
    ctx.lineTo(0,h);
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Sparkle particles (visual)
  const sparkles = [];
  function spawnSparkle(x,y, n=8){
    for(let i=0;i<n;i++){
      sparkles.push({
        x,y,
        vx:(Math.random()*2-1)*0.9,
        vy:(Math.random()*2-1)*0.9,
        life: 1,
        s: Math.random()*2+1,
        hue: 45 + Math.random()*25
      });
    }
  }
  function updateSparkles(dt){
    for(let i=sparkles.length-1;i>=0;i--){
      const p = sparkles[i];
      p.life -= dt*1.2;
      p.x += p.vx*60*dt;
      p.y += p.vy*60*dt;
      p.vx *= 0.98; p.vy *= 0.98;
      if(p.life <= 0) sparkles.splice(i,1);
    }
  }
  function drawSparkles(){
    for(const p of sparkles){
      ctx.save();
      ctx.globalAlpha = clamp(p.life,0,1);
      ctx.fillStyle = `hsl(${p.hue} 95% 65%)`;
      ctx.translate(p.x,p.y);
      ctx.rotate((1-p.life)*5);
      ctx.beginPath();
      ctx.moveTo(0,-p.s*2);
      ctx.lineTo(p.s*0.7, -p.s*0.5);
      ctx.lineTo(p.s*2, 0);
      ctx.lineTo(p.s*0.7, p.s*0.5);
      ctx.lineTo(0, p.s*2);
      ctx.lineTo(-p.s*0.7, p.s*0.5);
      ctx.lineTo(-p.s*2, 0);
      ctx.lineTo(-p.s*0.7, -p.s*0.5);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
    ctx.globalAlpha = 1;
  }

  // Collectibles
  const collectibles = [];
  function resetCollectibles(){
    collectibles.length = 0;
    const {w,h} = px();
    for(let i=0;i<SPARKLE_TARGET;i++){
      collectibles.push({
        x: w*(0.12 + Math.random()*0.55),
        y: h*(0.12 + Math.random()*0.55),
        r: 12 + Math.random()*6,
        taken: false,
        tw: Math.random()*Math.PI*2
      });
    }
  }
  resetCollectibles();

  function drawCollectibles(time){
    for(const c of collectibles){
      if(c.taken) continue;
      const tw = 0.6 + 0.4*Math.sin(time*0.004 + c.tw);
      ctx.save();
      ctx.globalAlpha = 0.75 + 0.25*tw;
      ctx.translate(c.x, c.y);
      ctx.rotate((1-tw)*0.8);
      ctx.fillStyle = "#ffcc55";
      ctx.beginPath();
      const r1 = c.r, r2 = c.r*0.45;
      for(let i=0;i<10;i++){
        const a = (Math.PI*2*i)/10 - Math.PI/2;
        const rr = i%2===0 ? r1 : r2;
        ctx.lineTo(Math.cos(a)*rr, Math.sin(a)*rr);
      }
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
  }

  // Keyboard input
  const keys = new Set();
  addEventListener("keydown", (e)=> keys.add(e.key.toLowerCase()));
  addEventListener("keyup",   (e)=> keys.delete(e.key.toLowerCase()));

  // ---------- Mobile joystick ----------
  const isTouch = matchMedia("(pointer: coarse)").matches || "ontouchstart" in window;
  const joy = document.getElementById("joy");
  const knob = document.getElementById("knob");
  let joyActive = false, joyId = null;
  let joyVec = { x: 0, y: 0 };

  if(isTouch){
    joy.style.display = "block";
    const joyCenter = () => {
      const r = joy.getBoundingClientRect();
      return { cx: r.left + r.width/2, cy: r.top + r.height/2, radius: r.width/2 };
    };

    const setKnob = (dx,dy)=>{
      const c = joyCenter();
      const max = c.radius - 26;
      const len = Math.hypot(dx,dy);
      const k = len > max ? max/len : 1;
      const nx = dx*k, ny = dy*k;
      knob.style.transform = `translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px))`;
      joyVec.x = clamp(nx / max, -1, 1);
      joyVec.y = clamp(ny / max, -1, 1);
    };

    joy.addEventListener("pointerdown", (e)=>{
      joyActive = true; joyId = e.pointerId;
      joy.setPointerCapture(joyId);
      const c = joyCenter();
      setKnob(e.clientX - c.cx, e.clientY - c.cy);
    }, {passive:false});

    joy.addEventListener("pointermove", (e)=>{
      if(!joyActive || e.pointerId !== joyId) return;
      const c = joyCenter();
      setKnob(e.clientX - c.cx, e.clientY - c.cy);
    }, {passive:false});

    const endJoy = ()=>{
      joyActive = false; joyId = null;
      joyVec.x = 0; joyVec.y = 0;
      knob.style.transform = "translate(-50%,-50%)";
    };
    joy.addEventListener("pointerup", endJoy, {passive:true});
    joy.addEventListener("pointercancel", endJoy, {passive:true});
  }

  const state = {
    t: 0,
    phase: 0, // 0 grow, 1 bloom, 2 play, 3 deliver/open, 4 note
    score: 0,
    flower: { x: 0, y: 0, vx: 0, vy: 0 },
    dragging: false,
    dragOffsetX: 0,
    dragOffsetY: 0,
    _deliverStart: 0,
    replay(){
      this.t=0; this.phase=0; sparkles.length=0;
      this.score=0;
      resetCollectibles();
    }
  };

  canvas.addEventListener("pointerdown", (e)=>{
    const mx = e.clientX, my = e.clientY;
    if(dist2(mx,my, state.flower.x, state.flower.y) < 70*70){
      state.dragging = true;
      state.dragOffsetX = state.flower.x - mx;
      state.dragOffsetY = state.flower.y - my;
      canvas.setPointerCapture(e.pointerId);
    } else {
      state.replay();
    }
  }, {passive:false});

  canvas.addEventListener("pointermove", (e)=>{
    if(!state.dragging) return;
    state.flower.x = e.clientX + state.dragOffsetX;
    state.flower.y = e.clientY + state.dragOffsetY;
  }, {passive:true});

  canvas.addEventListener("pointerup", ()=>{ state.dragging = false; }, {passive:true});
  canvas.addEventListener("pointercancel", ()=>{ state.dragging = false; }, {passive:true});

  function drawEnvelope(x,y, openAmount){
    ctx.save();
    ctx.translate(x,y);

    const w = 220, h = 140;

    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(0, h*0.62, w*0.52, h*0.14, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.fillStyle = "#f7f1e5";
    ctx.strokeStyle = "rgba(0,0,0,.12)";
    ctx.lineWidth = 2;
    roundRect(-w/2, -h/2, w, h, 14);
    ctx.fill(); ctx.stroke();

    ctx.globalAlpha = 0.6;
    ctx.fillStyle = "#f1e7d6";
    roundRect(-w/2+10, -h/2+10, w-20, h-20, 12);
    ctx.fill();
    ctx.globalAlpha = 1;

    const flapAngle = lerp(0, -Math.PI*0.92, easeOutCubic(openAmount));
    ctx.save();
    ctx.translate(0, -h/2);
    ctx.rotate(flapAngle);
    ctx.fillStyle = "#fbf6ee";
    ctx.strokeStyle = "rgba(0,0,0,.10)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-w/2, 0);
    ctx.lineTo(0, h*0.62);
    ctx.lineTo(w/2, 0);
    ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.restore();

    ctx.fillStyle = "#efe4d2";
    ctx.beginPath();
    ctx.moveTo(-w/2, h/2);
    ctx.lineTo(0, 0);
    ctx.lineTo(w/2, h/2);
    ctx.closePath();
    ctx.fill();

    ctx.save();
    ctx.translate(0, h*0.18);
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "#ff5a8a";
    heart(0,0, 14);
    ctx.fill();
    ctx.restore();

    ctx.restore();

    function roundRect(x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }
    function heart(cx,cy,s){
      ctx.beginPath();
      ctx.moveTo(cx, cy + s*0.30);
      ctx.bezierCurveTo(cx - s, cy - s*0.35, cx - s*0.20, cy - s*1.05, cx, cy - s*0.40);
      ctx.bezierCurveTo(cx + s*0.20, cy - s*1.05, cx + s, cy - s*0.35, cx, cy + s*0.30);
      ctx.closePath();
    }
  }

  function wrapTextToLines(text, maxWidth){
    const rawLines = text.split("\n");
    const lines = [];
    for(const raw of rawLines){
      const words = raw.split(/\s+/).filter(Boolean);
      if(words.length === 0){ lines.push(""); continue; }
      let line = words[0];
      for(let i=1;i<words.length;i++){
        const test = line + " " + words[i];
        if(ctx.measureText(test).width <= maxWidth) line = test;
        else { lines.push(line); line = words[i]; }
      }
      lines.push(line);
    }
    return lines;
  }

  function drawNote(x, y, alpha){
  const vw = window.innerWidth;

  // Responsive scaling for small screens
  const scale = Math.min(1, Math.max(0.82, vw / 420));

  const w = 390 * scale;
  const h = 260 * scale;
  const radius = 16 * scale;

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.translate(x,y);
  ctx.rotate(-0.03);

  ctx.beginPath();
  ctx.roundRect(-w/2, -h/2, w, h, radius);
  ctx.clip();

  if(noteBgReady){
    const iw = noteBg.naturalWidth;
    const ih = noteBg.naturalHeight;
    const s = Math.max(w/iw, h/ih);
    ctx.drawImage(
      noteBg,
      -iw*s/2,
      -ih*s/2,
      iw*s,
      ih*s
    );
  } else {
    ctx.fillStyle = "#fffaf2";
    ctx.fillRect(-w/2, -h/2, w, h);
  }

  // readability overlay
  ctx.fillStyle = "rgba(255,255,255,0.78)";
  ctx.fillRect(-w/2, -h/2, w, h);
  ctx.restore();

  // border + text
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.translate(x,y);
  ctx.rotate(-0.03);

  ctx.strokeStyle = "rgba(0,0,0,0.12)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.roundRect(-w/2, -h/2, w, h, radius);
  ctx.stroke();

  ctx.fillStyle = "rgba(0,0,0,0.85)";
  ctx.font = `700 ${18 * scale}px system-ui`;
  ctx.fillText(`To: ${TO_NAME}`, -w/2 + 22*scale, -h/2 + 44*scale);

  ctx.font = `${18 * scale}px system-ui`;
  const maxTextWidth = w - 44*scale;
  const wrapped = wrapTextToLines(MESSAGE, maxTextWidth);

  let yy = -h/2 + 80*scale;
  const lineH = 26*scale;
  const maxLines = Math.floor((h - 105*scale) / lineH);

  for(const line of wrapped.slice(0, maxLines)){
    ctx.fillText(line, -w/2 + 22*scale, yy);
    yy += lineH;
  }

  ctx.restore();
}


  function drawFlower(x,y, scale, bob, petalOpen){
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    ctx.rotate(bob);

    ctx.lineCap="round";
    ctx.strokeStyle = "#39c172";
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.moveTo(0, 160);
    ctx.quadraticCurveTo(-18, 70, 0, 0);
    ctx.stroke();

    ctx.fillStyle = "#2bbf6a";
    leaf(-18, 90, -0.7);
    leaf(18, 110, 0.8);

    ctx.fillStyle = "#ffcc3d";
    ctx.beginPath();
    ctx.arc(0, 0, 22, 0, Math.PI*2);
    ctx.fill();

    const petals = 8;
    for(let i=0;i<petals;i++){
      const a = (Math.PI*2*i)/petals;
      const open = lerp(0.35, 1.0, petalOpen);
      ctx.save();
      ctx.rotate(a);
      ctx.translate(0, -42*open);
      const grad = ctx.createRadialGradient(0,-10,6, 0,-10, 44);
      grad.addColorStop(0, "#ffd4e2");
      grad.addColorStop(1, "#ff6aa2");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(0, 0, 18, 42, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "rgba(255,255,255,.9)";
    ctx.beginPath(); ctx.arc(-8,-6,4,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(10,-3,3,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;

    ctx.restore();

    function leaf(x,y, rot){
      ctx.save();
      ctx.translate(x,y);
      ctx.rotate(rot);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.quadraticCurveTo(50,-10, 60,20);
      ctx.quadraticCurveTo(30,45, 0,0);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
  }

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    const {w,h} = px();

    drawBackground(now);
    drawGround();

    const envX = w*0.74;
    const envY = h*0.62;
    const baseX = w*0.28;
    const baseY = h*0.72;

    if(state.t < 0.05){
      state.flower.x = baseX;
      state.flower.y = baseY - 190;
    }

    state.t += dt;

    const growT = 1.6, bloomT = 0.9;
    const deliverT = 1.5, noteT = 1.6;

    if(state.phase === 0 && state.t > growT) state.phase = 1;
    if(state.phase === 1 && state.t > growT + bloomT) state.phase = 2;

    let flowerX = state.flower.x;
    let flowerY = state.flower.y;
    let stemScale = 1, petalOpen = 1;
    let bob = Math.sin(now*0.008)*0.03;

    // grow
    if(state.phase === 0){
      const p = easeOutCubic(clamp(state.t/growT,0,1));
      stemScale = lerp(0.25, 1.0, p);
      petalOpen = 0.15 * p;
      flowerX = baseX;
      flowerY = baseY - lerp(30, 190, p);
      state.flower.x = flowerX; state.flower.y = flowerY;
      if(Math.random() < dt*6) spawnSparkle(baseX, baseY - 120, 1);
    }

    // bloom
    if(state.phase === 1){
      const p = easeInOutSine(clamp((state.t - growT)/bloomT,0,1));
      stemScale = 1.0;
      petalOpen = lerp(0.15, 1.0, p);
      flowerX = baseX;
      flowerY = baseY - 190;
      state.flower.x = flowerX; state.flower.y = flowerY;
      if(Math.random() < dt*14) spawnSparkle(flowerX + (Math.random()*60-30), flowerY + (Math.random()*60-30), 1);
    }

    let openAmount = 0, noteAlpha = 0;

    // play
    if(state.phase === 2){
      drawCollectibles(now);

      if(!state.dragging){
        const accel = 1200;
        let ax = 0, ay = 0;

        const k = (s)=>keys.has(s);
        if(k("arrowleft")||k("a")) ax -= 1;
        if(k("arrowright")||k("d")) ax += 1;
        if(k("arrowup")||k("w")) ay -= 1;
        if(k("arrowdown")||k("s")) ay += 1;

        // joystick
        ax += joyVec.x;
        ay += joyVec.y;

        state.flower.vx += ax * accel * dt;
        state.flower.vy += ay * accel * dt;

        state.flower.vx *= 0.88;
        state.flower.vy *= 0.88;

        const maxV = 520;
        state.flower.vx = clamp(state.flower.vx, -maxV, maxV);
        state.flower.vy = clamp(state.flower.vy, -maxV, maxV);

        state.flower.x += state.flower.vx * dt;
        state.flower.y += state.flower.vy * dt;
      }

      state.flower.x = clamp(state.flower.x, 40, w - 40);
      state.flower.y = clamp(state.flower.y, 60, h*0.72 - 20);

      flowerX = state.flower.x;
      flowerY = state.flower.y + Math.sin(now*0.006)*4;

      for(const c of collectibles){
        if(c.taken) continue;
        if(dist2(flowerX, flowerY, c.x, c.y) < (c.r+30)*(c.r+30)){
          c.taken = true;
          state.score++;
          spawnSparkle(c.x, c.y, 10);
        }
      }

      if(dist2(flowerX, flowerY, envX, envY) < DELIVERY_RADIUS*DELIVERY_RADIUS){
        state.phase = 3;
        state._deliverStart = now;
        spawnSparkle(envX, envY, 18);
      }

      if(Math.random() < dt*6) spawnSparkle(flowerX, flowerY, 1);
    }

    // deliver + note
    if(state.phase === 3 || state.phase === 4){
      const deliverElapsed = (now - (state._deliverStart || now)) / 1000;

      if(deliverElapsed < deliverT){
        const p = easeOutCubic(clamp(deliverElapsed/deliverT,0,1));
        flowerX = lerp(state.flower.x, envX, p);
        flowerY = lerp(state.flower.y, envY - 10, p);
        openAmount = easeOutCubic(clamp((deliverElapsed/deliverT - 0.30)/0.70, 0, 1));
        if(Math.random() < dt*18) spawnSparkle(flowerX, flowerY, 2);
      } else {
        state.phase = 4;
        openAmount = 1;
        const noteElapsed = deliverElapsed - deliverT;
        noteAlpha = easeOutCubic(clamp(noteElapsed/noteT,0,1));
        flowerX = envX;
        flowerY = envY - 10;
      }
    }

    drawEnvelope(envX, envY, openAmount);
    drawFlower(flowerX, flowerY, stemScale, bob, petalOpen);

    if(noteAlpha > 0){
      // responsive note placement
      const noteX = w < 420 ? envX - 10 : envX - 140;
      const noteY = w < 420 ? envY - 280 : envY - 250;
      drawNote(noteX, noteY, noteAlpha);
    }

    updateSparkles(dt);
    drawSparkles();

    // HUD
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(255,255,255,.88)";
    ctx.font = "800 22px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("", 24, 42);

    ctx.globalAlpha = 0.80;
    ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    if(state.phase === 2){
      ctx.fillText(`Sparkles: ${state.score}/${SPARKLE_TARGET} â€¢ Deliver to envelope ðŸ’Œ`, 24, 70);
    } else if(state.phase >= 3){
      ctx.fillText(`Delivered âœ…  Sparkles: ${state.score}/${SPARKLE_TARGET}`, 24, 70);
    } else {
      ctx.fillText("Magic growingâ€¦", 24, 70);
    }
    ctx.restore();

    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
